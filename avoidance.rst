Chapter 5:  Avoidance-Based Algorithms
======================================

A review of the academic literature on TCP congestion control shows a
notiable gap between the original TCP Tahoe and Reno mechanisms
introduced in 1988 and 1990, respectively, and the next major flurry
of activity starting in 1994, marked by the introduction of an
alternative approach known as TCP Vegas. This triggered an avalanche
of comparative studies and alternative designs that would persist for
the next 25+ years.

.. _reading_vegas:
.. admonition:: Further Reading 

      L. Brakmo, S. O'Malley and L. Peterson
      `TCP Vegas: New Technique for Congestion Detection and Avoidance
      <https://sites.cs.ucsb.edu/~almeroth/classes/F05.276/papers/vegas.pdf>`__.
      ACM SIGCOMM '94 Symposium. August 1994. (Reprinted in IEEE/ACM Transactions 
      on Networking, October 1995).

TCP Vegas takes an *avoidance-based* approach to congestion control in
that it tries to detect changes in the measured throughput rate, and
adjust the sending rate before congestion becomes severe enough to
cause packet loss. This chapter describes the general "Vegas strategy"
and—as we did with Tahoe/Reno in the previous chapter—walks through
the incremental changes applied to that strategy over time. This case
study culminates in the BBR algorithm championed by Google today.

5.1 TCP Vegas
-------------

The essential idea behind TCP Vegas is to adapt the sending rate based
on a comparison of the *measured* throughput rate with the *expected*
throughput rate. The intuition can be seen in the trace of TCP Reno
given in :numref:`Figure %s <fig-trace3>`. The top graph traces the
connection’s congestion window; it shows the same information as the
traces given earlier in this section.  The middle and bottom graphs
depict new information: The middle graph shows the average sending
rate as measured at the source, and the bottom graph shows the average
queue length as measured at the bottleneck router. All three graphs
are synchronized in time. In the period between 4.5 and 6.0 seconds
(shaded region), the congestion window increases (top graph). We
expect the observed throughput to also increase, but instead it stays
flat (middle graph). This is because the throughput cannot increase
beyond the available bandwidth. Beyond this point, any increase in the
window size only results in packets taking up buffer space at the
bottleneck router (bottom graph).

.. _fig-trace3:
.. figure:: figures/f06-18-9780123850591.png
   :width: 600px
   :align: center

   Congestion window versus observed throughput rate (the
   three graphs are synchronized). Top, congestion window; middle,
   observed throughput; bottom, buffer space taken up at the
   router. Colored line = `CongestionWindow`; solid bullet = timeout;
   hash marks = time when each packet is transmitted; vertical bars =
   time when a packet that was eventually retransmitted was first
   transmitted.

A useful metaphor that describes the phenomenon illustrated in
:numref:`Figure %s <fig-trace3>` is driving on ice. The speedometer
(congestion window) may say that you are going 30 miles an hour, but
by looking out the car window and seeing people pass you on foot
(measured throughput rate) you know that you are going no more than 5
miles an hour. The extra energy is being absorbed by the car’s tires
(router buffers).

TCP Vegas uses this idea to measure and control the amount of extra data
this connection has in transit, where by “extra data” we mean data that
the source would not have transmitted had it been trying to match
exactly the available bandwidth of the network. The goal of TCP Vegas is
to maintain the “right” amount of extra data in the network. Obviously,
if a source is sending too much extra data, it will cause long delays
and possibly lead to congestion. Less obviously, if a connection is
sending too little extra data, it cannot respond rapidly enough to
transient increases in the available network bandwidth. TCP Vegas’s
congestion-avoidance actions are based on changes in the estimated
amount of extra data in the network, not only on dropped packets. We now
describe the algorithm in detail.

First, define a given flow’s ``BaseRTT`` to be the RTT of a packet when
the flow is not congested. In practice, TCP Vegas sets ``BaseRTT`` to
the minimum of all measured round-trip times; it is commonly the RTT of
the first packet sent by the connection, before the router queues
increase due to traffic generated by this flow. If we assume that we are
not overflowing the connection, then the expected throughput is given by

::

   ExpectedRate = CongestionWindow / BaseRTT

where ``CongestionWindow`` is the TCP congestion window, which we
assume (for the purpose of this discussion) to be equal to the number
of bytes in transit.

Second, TCP Vegas calculates the current sending rate, ``ActualRate``.
This is done by recording the sending time for a distinguished packet,
recording how many bytes are transmitted between the time that packet
is sent and when its acknowledgment is received, computing the sample
RTT for the distinguished packet when its acknowledgment arrives, and
dividing the number of bytes transmitted by the sample RTT. This
calculation is done once per round-trip time.

Third, TCP Vegas compares ``ActualRate`` to ``ExpectedRate`` and
adjusts the window accordingly. We let ``Diff = ExpectedRate -
ActualRate``.  Note that ``Diff`` is positive or 0 by definition,
since ``ActualRate >ExpectedRate`` implies that we need to change
``BaseRTT`` to the latest sampled RTT. We also define two thresholds,
*α < β*, roughly corresponding to having too little and too much extra
data in the network, respectively. When ``Diff`` < *α*, TCP Vegas
increases the congestion window linearly during the next RTT, and when
``Diff`` > *β*, TCP Vegas decreases the congestion window linearly
during the next RTT.  TCP Vegas leaves the congestion window unchanged
when *α* < ``Diff`` < *β*.

Intuitively, we can see that the farther away the actual throughput
gets from the expected throughput, the more congestion there is in the
network, which implies that the sending rate should be reduced. The
*β* threshold triggers this decrease. On the other hand, when the
actual throughput rate gets too close to the expected throughput, the
connection is in danger of not utilizing the available bandwidth. The
*α* threshold triggers this increase. The overall goal is to keep
between\ *α* and *β* extra bytes in the network.

.. _fig-vegas:
.. figure:: figures/f06-19-9780123850591.png
   :width: 600px
   :align: center

   Trace of TCP Vegas congestion-avoidance mechanism.
   Top, congestion window; bottom, expected (colored line) and actual
   (black line) throughput. The shaded area is the region between the
   *α* and *β* thresholds.

:numref:`Figure %s <fig-vegas>` traces the TCP Vegas
congestion-avoidance algorithm. The top graph traces the congestion
window, showing the same information as the other traces given
throughout this chapter. The bottom graph traces the expected and
actual throughput rates that govern how the congestion window is
set. It is this bottom graph that best illustrates how the algorithm
works. The colored line tracks the ``ExpectedRate``, while the black
line tracks the ``ActualRate``. The wide shaded strip gives the region
between the *α* and *β* thresholds; the top of the shaded strip is
*α* KBps away from ``ExpectedRate``, and the bottom of the shaded
strip is *β* KBps away from ``ExpectedRate``.  The goal is to keep the
``ActualRate`` between these two thresholds, within the shaded
region. Whenever ``ActualRate`` falls below the shaded region (i.e.,
gets too far from ``ExpectedRate``), TCP Vegas decreases the
congestion window because it fears that too many packets are being
buffered in the network. Likewise, whenever ``ActualRate`` goes above
the shaded region (i.e., gets too close to the ``ExpectedRate``), TCP
Vegas increases the congestion window because it fears that it is
underutilizing the network.

Because the algorithm, as just presented, compares the difference
between the actual and expected throughput rates to the *α* and *β*
thresholds, these two thresholds are defined in terms of KBps. However,
it is perhaps more accurate to think in terms of how many extra
*buffers* the connection is occupying in the network. For example, on a
connection with a ``BaseRTT`` of 100 ms and a packet size of 1 KB, if
*α* = 30 KBps and *β* = 60 KBps, then we can think of *α* as specifying
that the connection needs to be occupying at least 3 extra buffers in
the network and *β* as specifying that the connection should occupy no
more than 6 extra buffers in the network. In practice, a setting of *α*
to 1 buffer and *β* to 3 buffers works well.

Finally, you will notice that TCP Vegas decreases the congestion window
linearly, seemingly in conflict with the rule that multiplicative
decrease is needed to ensure stability. The explanation is that TCP
Vegas does use multiplicative decrease when a timeout occurs; the linear
decrease just described is an *early* decrease in the congestion window
that should happen before congestion occurs and packets start being
dropped.

5.2 New Vegas
---------------

..
	Case-study mode: Highlight experience/limitations/solutions.
	Maybe mention other derivatives, including TCP FAST. -llp

5.3 TCP BBR 
---------------

..
	This is too brief. Exposing the churn of ideas and ongoing
	tweaks is fine. -llp
	
BBR (Bottleneck Bandwidth and RTT) is a new TCP congestion control
algorithm developed by researchers at Google. Like Vegas, BBR is delay
based, which means it tries to detect buffer growth so as to avoid
congestion and packet loss. Both BBR and Vegas use the minimum RTT and
maximum RTT, as calculated over some time interval, as their main
control signals.

BBR also introduces new mechanisms to improve performance, including
packet pacing, bandwidth probing, and RTT probing. Packet pacing spaces
the packets based on the estimate of the available bandwidth. This
eliminates bursts and unnecessary queueing, which results in a better
feedback signal. BBR also periodically increases its rate, thereby
probing the available bandwidth. Similarly, BBR periodically decreases
its rate, thereby probing for a new minimum RTT. The RTT probing
mechanism attempts to be self-synchronizing, which is to say, when there
are multiple BBR flows, their respective RTT probes happen at the same
time. This gives a more accurate view of the actual uncongested path
RTT, which solves one of the major issues with delay-based congestion
control mechanisms: having accurate knowledge of the uncongested path
RTT.

BBR is actively being worked on and rapidly evolving. One major focus is
fairness. For example, some experiments show CUBIC flows get 100× less
bandwidth when competing with BBR flows, and other experiments show that
unfairness among BBR flows is even possible. Another major focus is
avoiding high retransmission rates, where in some cases as many as 10%
of packets are retransmitted.

5.4 Retrospective
--------------------
